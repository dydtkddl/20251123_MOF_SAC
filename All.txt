#!/usr/bin/env python3
# -*- coding: utf-8 -*-

##############################################
# train_mof_phase2.py
# Phase 2: QMOF + Small Perturb + Warm-up
# - Load Phase1 SAC checkpoint
# - New ReplayBuffer + Warm-up
# - Reset-time random perturb (sigma 0.02~0.08 Å, max 0.3 Å)
##############################################

import os
import time
import numpy as np
import logging
from logging.handlers import RotatingFileHandler
from tqdm import tqdm
import torch

from ase.io import read
from mace.calculators import MACECalculator

from env.mof_env import MOFEnv
from sac.agent import SACAgent
from utils.replay_buffer import ReplayBuffer


##############################################
# LOGGING SETUP (Phase2 전용 log 파일)
##############################################
log_handler = RotatingFileHandler(
    "train_phase2.log",
    maxBytes=20_000_000,
    backupCount=10,
)
log_handler.setFormatter(logging.Formatter(
    "%(asctime)s - %(levelname)s - %(message)s"
))

logger = logging.getLogger("train_phase2")
logger.setLevel(logging.INFO)
logger.addHandler(log_handler)


##############################################
# CHECKPOINT I/O
##############################################
PHASE1_CKPT = "phase01_qmof_20251129/checkpoints/ckpt_ep1500_final.pt"#  "checkpoints/ckpt_ep1500_final.pt"  # <- 여기만 필요시 변경

def save_checkpoint(ep, agent, tag="phase2"):
    os.makedirs("checkpoints_phase2", exist_ok=True)
    ckpt = {
        "epoch": ep,
        "actor": agent.actor.state_dict(),
        "q1": agent.q1.state_dict(),
        "q2": agent.q2.state_dict(),
        "v": agent.v.state_dict(),
        "v_tgt": agent.v_tgt.state_dict(),
        "log_alpha": float(agent.log_alpha.detach().cpu()),
    }
    p = f"checkpoints_phase2/ckpt_ep{ep:04d}_{tag}.pt"
    torch.save(ckpt, p)
    logger.info(f"[CHECKPOINT] Saved => {p}")


def load_phase1_checkpoint(agent, ckpt_path):
    device = agent.device
    ckpt = torch.load(ckpt_path, map_location=device)

    agent.actor.load_state_dict(ckpt["actor"])
    agent.q1.load_state_dict(ckpt["q1"])
    agent.q2.load_state_dict(ckpt["q2"])
    agent.v.load_state_dict(ckpt["v"])
    agent.v_tgt.load_state_dict(ckpt["v_tgt"])

    # log_alpha 복원
    with torch.no_grad():
        agent.log_alpha.data.fill_(ckpt["log_alpha"])

    logger.info(f"[LOAD] Loaded Phase1 checkpoint from {ckpt_path}")
    logger.info(f"[LOAD] log_alpha={ckpt['log_alpha']:.6f}")


##############################################
# CIF SAMPLING (QMOF pool)
##############################################
POOL_DIR = "mofs/train_pool_valid"

def sample_cif():
    cifs = [
        os.path.join(POOL_DIR, f)
        for f in os.listdir(POOL_DIR)
        if f.endswith(".cif")
    ]
    return np.random.choice(cifs)


##############################################
# MACE Surrogate
##############################################
calc = MACECalculator(
    model_paths=["mofs_v2.model"],
    head="pbe_d3",
    device="cuda",
    default_dtype="float32"
)


##############################################
# CONFIG (Phase2)
##############################################
EPOCHS       = 1500          # Phase2는 조금 짧게 잡아도 됨 (원하면 조정)
BASE_STEPS   = 300
FINAL_STEPS  = 1000
HORIZON_SCH  = 500

FMAX_THRESH  = 0.05
BUFFER_SIZE  = 5_000_000
BATCH_SIZE   = 256

CHECKPOINT_INTERVAL   = 10
WARMUP_TRANSITIONS    = 50_000   # Phase2에서도 새로 warm-up

# Perturb 스케줄 범위
SIGMA_MIN = 0.02   # Å
SIGMA_MAX = 0.08   # Å
MAX_PERTURB = 0.20 # Å


def get_perturb_sigma(ep):
    """
    ep=0에서 SIGMA_MIN,
    ep=(EPOCHS/2) 이상에서 SIGMA_MAX
    그 사이에는 선형 증가.
    """
    t = min(ep / (EPOCHS / 2.0), 1.0)
    return SIGMA_MIN + (SIGMA_MAX - SIGMA_MIN) * t


##############################################
# TRAIN START
##############################################
logger.info(f"[MACS-MOF Phase2] Training start (EPOCHS={EPOCHS})")
logger.info(
    f"[CONFIG] BATCH_SIZE={BATCH_SIZE}, BUFFER_SIZE={BUFFER_SIZE:,}, "
    f"WARMUP_TRANSITIONS={WARMUP_TRANSITIONS:,}, "
    f"SIGMA_MIN={SIGMA_MIN:.3f}, SIGMA_MAX={SIGMA_MAX:.3f}, "
    f"MAX_PERTURB={MAX_PERTURB:.3f}"
)
global_start = time.time()


##############################################
# GLOBALS
##############################################
OBS_DIM = None
ACT_DIM = 3   # ALWAYS 3 for per-atom action
replay = None
agent = None


for ep in range(EPOCHS):

    logger.info("\n" + "=" * 80)
    logger.info(f"[EP {ep}] START")

    ##################################
    # Curriculum Horizon (동일)
    ##################################
    ratio = min(ep / HORIZON_SCH, 1.0)
    max_steps = int(BASE_STEPS + (FINAL_STEPS - BASE_STEPS) * ratio)
    logger.info(f"[EP {ep}] max_steps = {max_steps}")

    ##################################
    # Perturb sigma (Phase2 핵심)
    ##################################
    sigma_ep = get_perturb_sigma(ep)
    logger.info(f"[EP {ep}] perturb_sigma = {sigma_ep:.4f} Å, max_perturb={MAX_PERTURB:.3f} Å")

    ##################################
    # Snapshot folders
    ##################################
    snap_dir = f"snapshots_phase2/EP{ep:04d}"
    os.makedirs(snap_dir, exist_ok=True)

    traj_path = os.path.join(snap_dir, "traj.xyz")
    en_path = os.path.join(snap_dir, "energies.txt")

    if os.path.exists(traj_path):
        os.remove(traj_path)
    if os.path.exists(en_path):
        os.remove(en_path)

    ##################################
    # Load CIF and Init Env
    ##################################
    cif = sample_cif()
    atoms = read(cif)
    atoms.calc = calc

    env = MOFEnv(
        atoms_loader=lambda: atoms,
        k_neighbors=12,
        fmax_threshold=FMAX_THRESH,
        max_steps=max_steps,
        cmax=0.03,
        # Phase2: perturb 옵션 켜기
        random_perturb=True,
        perturb_sigma=sigma_ep,
        max_perturb=MAX_PERTURB,
    )

    obs = env.reset()
    logger.info(f"[EP {ep}] CIF loaded: {cif}")

    N_atom = env.N
    obs_dim = obs.shape[1]   # per-atom feature dim

    ##################################
    # EP0: Initialize Replay + Agent + Load Phase1 ckpt
    ##################################
    if ep == 0:
        OBS_DIM = obs_dim
        logger.info(f"[INIT] OBS_DIM={OBS_DIM}, ACT_DIM=3 (per-atom)")

        replay = ReplayBuffer(
            obs_dim=OBS_DIM,
            max_size=BUFFER_SIZE
        )

        agent = SACAgent(
            obs_dim=OBS_DIM,
            act_dim=3,
            replay_buffer=replay,
            device="cuda",
            lr=3e-4,
            gamma=0.995,
            tau=5e-3,
            batch_size=BATCH_SIZE,
        )
        logger.info("[INIT] Agent + ReplayBuffer allocated (per-atom).")

        # Phase1 checkpoint 로드
        load_phase1_checkpoint(agent, PHASE1_CKPT)


    ##################################
    # EPISODE
    ##################################
    ep_ret = 0.0

    for step in tqdm(range(max_steps), desc=f"[EP {ep}]", ncols=120):

        ########################
        # ACTION (per-atom)
        ########################
        obs_tensor = obs  # shape = (N_atom, obs_dim)

        action_list = []
        for i in range(N_atom):
            a = agent.act(obs_tensor[i])  # → (3,)
            action_list.append(a)

        action_arr = np.stack(action_list, axis=0)  # (N_atom, 3)

        ########################
        # STEP ENV
        ########################
        next_obs, reward, done = env.step(action_arr)
        # reward = per-atom reward shape (N_atom,)

        ########################
        # STORE (per-atom)
        ########################
        next_reward = reward.astype(np.float32)

        for i in range(N_atom):
            replay.store(
                obs[i],            # (obs_dim,)
                action_arr[i],     # (3,)
                next_reward[i],    # scalar
                next_obs[i],       # (obs_dim,)
                done,
            )

        # ------------------------
        # SAC 업데이트 (Replay warm-up 적용)
        # ------------------------
        if len(replay) > max(agent.batch_size, WARMUP_TRANSITIONS):
            losses = agent.update()
            logger.info(f"[EP {ep}][STEP {step}] losses={losses}")
        else:
            if len(replay) % 10_000 == 0:
                logger.info(
                    f"[WARMUP] replay={len(replay):,} / {WARMUP_TRANSITIONS:,} "
                    f"(batch={agent.batch_size})"
                )

        ########################
        # LOG & SAVE TRAJECTORY
        ########################
        env.atoms.write(traj_path, append=True)

        Etot = env.atoms.get_potential_energy()
        E_pa = Etot / N_atom

        with open(en_path, "a") as f:
            f.write(f"{step} {Etot:.8f} {E_pa:.8f}\n")

        f_norm = np.linalg.norm(env.forces, axis=1)

        logger.info(
            f"[EP {ep}][STEP {step}] "
            f"N={N_atom} | "
            f"Favg={np.mean(f_norm):.6f} Fmax={np.max(f_norm):.6f} "
            f"rew_mean={float(np.mean(next_reward)):.6f} | "
            f"replay={len(replay):,} | "
            f"alpha={float(agent.alpha):.5f}"
        )

        ep_ret += float(np.mean(next_reward))
        obs = next_obs

        if done:
            logger.info(f"[EP {ep}] terminated early at step={step}")
            break

    ##################################
    # EP END
    ##################################
    logger.info(f"[EP {ep}] return={ep_ret:.6f}")
    logger.info(f"[EP {ep}] replay_size={len(replay):,}")

    if ep % CHECKPOINT_INTERVAL == 0 and ep > 0:
        save_checkpoint(ep, agent, tag="interval")


##############################################
# FINAL SAVE
##############################################
save_checkpoint(EPOCHS, agent, tag="final")

logger.info("[TRAIN DONE] (Phase2)")
logger.info(f"wallclock={(time.time() - global_start)/3600:.3f} hr")

print("== Phase2 training finished ==")



# utils/replay_buffer.py

import numpy as np


class ReplayBuffer:
    """
    Stable MACS-style ReplayBuffer
    ---------------------------------------------------------
    Stores *per-atom transitions*:
        obs_i       : (obs_dim,)
        act_i       : (3,)          # dx, dy, dz
        reward_i    : float
        next_obs_i  : (obs_dim,)
        done        : bool
    ---------------------------------------------------------
    """

    def __init__(
        self,
        obs_dim: int,
        max_size: int = 5_000_000,
    ):
        """
        act_dim is fixed to 3 for stable MACS-style SAC.
        """

        self.obs_dim = obs_dim
        self.act_dim = 3                # ALWAYS dx, dy, dz
        self.max_size = max_size

        self.ptr = 0
        self.size = 0

        # Buffers
        self.obs_buf = np.zeros((max_size, obs_dim), dtype=np.float32)
        self.nobs_buf = np.zeros((max_size, obs_dim), dtype=np.float32)

        self.act_buf = np.zeros((max_size, 3), dtype=np.float32)
        self.rew_buf = np.zeros(max_size, dtype=np.float32)
        self.done_buf = np.zeros(max_size, dtype=np.bool_)


    # ============================================================
    # STORE ONE ATOM TRANSITION
    # ============================================================
    def store(self, obs_i, act_i, rew_i, next_obs_i, done_i):
        """
        Parameters
        ----------
        obs_i : np.ndarray (obs_dim,)
        act_i : np.ndarray (3,)
        rew_i : float
        next_obs_i : np.ndarray (obs_dim,)
        done_i : bool
        """

        self.obs_buf[self.ptr] = obs_i
        self.act_buf[self.ptr] = act_i
        self.rew_buf[self.ptr] = rew_i
        self.nobs_buf[self.ptr] = next_obs_i
        self.done_buf[self.ptr] = done_i

        self.ptr = (self.ptr + 1) % self.max_size
        self.size = min(self.size + 1, self.max_size)


    # ============================================================
    # SAMPLE MINI-BATCH
    # ============================================================
    def sample(self, batch_size):
        """
        Randomly sample per-atom transitions
        """

        idxs = np.random.randint(0, self.size, size=batch_size)

        return dict(
            obs=self.obs_buf[idxs],
            act=self.act_buf[idxs],
            rew=self.rew_buf[idxs],
            nobs=self.nobs_buf[idxs],
            done=self.done_buf[idxs],
        )


    def __len__(self):
        return self.size
# env/mof_env.py

import numpy as np
from ase.neighborlist import neighbor_list
from ase.data import covalent_radii


class MOFEnv:

    # ============================================================
    def __init__(
        self,
        atoms_loader,
        k_neighbors=12,
        cmax=0.4,
        max_steps=300,
        fmax_threshold=0.05,
        bond_break_ratio=2.4,
        k_bond=3.0,
        max_penalty=10.0,
        debug_bond=False,
        # ---------- Phase2: perturb 옵션 ----------
        random_perturb=False,
        perturb_sigma=0.05,
        max_perturb=0.3,
    ):
        self.atoms_loader = atoms_loader

        self.k = k_neighbors
        self.cmax = cmax
        self.max_steps = max_steps
        self.fmax_threshold = fmax_threshold

        # Bond-related
        self.bond_break_ratio = bond_break_ratio
        self.k_bond = k_bond
        self.max_penalty = max_penalty
        self.debug_bond = debug_bond

        # COM control (stabilized)
        self.com_threshold = 0.30
        self.com_lambda = 20.0    #  previously 100 × 0.1=10, now stabilized

        # Phase2: perturb 옵션 저장
        self.random_perturb = random_perturb
        self.perturb_sigma = perturb_sigma
        self.max_perturb = max_perturb

        self.feature_dim = None
        #self.reset()

    # ============================================================
    # True Bonds
    # ============================================================
    def _detect_true_bonds(self, atoms):

        i, j, offsets = neighbor_list("ijS", atoms, cutoff=4.0)

        pos = atoms.positions
        cell = atoms.cell

        bond_pairs = []
        bond_d0 = []

        for a, b, off in zip(i, j, offsets):
            rel = pos[b] + off @ cell - pos[a]
            d = np.linalg.norm(rel)

            rc = covalent_radii[atoms[a].number] + covalent_radii[atoms[b].number]

            if d <= rc + 0.4:
                bond_pairs.append((a, b))
                bond_d0.append(d)

        return np.array(bond_pairs, int), np.array(bond_d0, float)

    # ============================================================
    # Aromatic detection
    # ============================================================
    def _detect_aromatic_nodes(self, adj, Z):
        N = len(Z)
        aromatic = set()
        visited = set()

        def canonical(cycle):
            L = len(cycle)
            seqs = []
            for r in range(L):
                seqs.append(tuple(cycle[r:] + cycle[:r]))
            rev = list(reversed(cycle))
            for r in range(L):
                seqs.append(tuple(rev[r:] + rev[:r]))
            return min(seqs)

        def dfs(s, path, depth):
            if depth > 6:
                return
            last = path[-1]

            for nxt in adj[last]:
                if nxt == s and depth == 6:
                    cyc = canonical(path.copy())
                    if cyc not in visited:
                        if all(Z[x] == 6 and len(adj[x]) <= 3 for x in cyc):
                            aromatic.update(cyc)
                        visited.add(cyc)
                elif nxt > s and nxt not in path:
                    dfs(s, path + [nxt], depth + 1)

        for s in range(N):
            if Z[s] == 6 and len(adj[s]) <= 3:
                dfs(s, [s], 1)

        return aromatic

    # ============================================================
    def _assign_metal_flags(self, Z):
        MOF_METALS = {12,13,20,22,23,24,25,26,27,28,29,30,40,72}
        return np.array([1.0 if z in MOF_METALS else 0.0 for z in Z], float)

    def _detect_carboxylate_O(self, Z, adj, is_metal):
        N = len(Z)
        out = np.zeros(N, float)

        for O in range(N):
            if Z[O] != 8:
                continue
            for C in adj[O]:
                if Z[C] != 6:
                    continue

                O_list = [x for x in adj[C] if Z[x] == 8]
                if len(O_list) != 2:
                    continue

                if sum(is_metal[n] for n in adj[C]) >= 1:
                    out[O] = 1.0
                    break

        return out

    def _detect_mu_oxygens(self, Z, adj, is_metal):
        N = len(Z)
        mu2 = np.zeros(N, float)
        mu3 = np.zeros(N, float)

        for O in range(N):
            if Z[O] != 8:
                continue
            m = sum(is_metal[n] for n in adj[O])
            if m == 2:
                mu2[O] = 1.0
            elif m >= 3:
                mu3[O] = 1.0
        return mu2, mu3

    # ============================================================
    # Phase2: reset perturb
    # ============================================================
    def _apply_random_perturbation(self):
        """
        QMOF 구조에 작은 Gaussian 노이즈를 주되,
        원자별 변위 norm이 max_perturb를 넘지 않게 클리핑.
        """
        if (not self.random_perturb) or self.perturb_sigma <= 0.0:
            return

        pos = self.atoms.positions.copy()
        N = len(pos)

        # 1) 기본 Gaussian noise
        delta = np.random.normal(
            loc=0.0,
            scale=self.perturb_sigma,
            size=pos.shape
        )

        # 2) 원자당 max_perturb 클리핑
        if self.max_perturb is not None:
            norms = np.linalg.norm(delta, axis=1, keepdims=True)  # (N,1)
            norms_safe = np.maximum(norms, 1e-12)
            scale = np.minimum(1.0, self.max_perturb / norms_safe)
            delta = delta * scale

        self.atoms.positions = pos + delta

        max_disp = np.linalg.norm(delta, axis=1).max()
        print(
            f"[PERTURB] sigma={self.perturb_sigma:.3f} Å, "
            f"max_disp={max_disp:.3f} Å (max_perturb={self.max_perturb:.3f} Å)"
        )

    # ============================================================
    # RESET
    # ============================================================
    def reset(self):
        # 1) 깨끗한 QMOF 구조 로드
        self.atoms = self.atoms_loader()
        self.N = len(self.atoms)

        Z = np.array([a.number for a in self.atoms])
        self.covalent_radii = np.array([covalent_radii[z] for z in Z]).astype(np.float32)

        # 2) 원래 구조 기준으로 bond & bond_d0 계산
        self.bond_pairs, self.bond_d0 = self._detect_true_bonds(self.atoms)
        print(f"[INIT] Detected true bonds = {len(self.bond_pairs)}")

        # 3) adjacency & 역할 플래그 등 계산
        self.adj = {i: [] for i in range(self.N)}
        for a, b in self.bond_pairs:
            self.adj[a].append(b)
            self.adj[b].append(a)

        aromatic_nodes = self._detect_aromatic_nodes(self.adj, Z)
        self.is_aromatic = np.zeros(self.N, float)
        self.is_aromatic[list(aromatic_nodes)] = 1.0

        self.is_metal = self._assign_metal_flags(Z)
        self.is_carboxylate_O = self._detect_carboxylate_O(Z, self.adj, self.is_metal)
        self.is_mu2O, self.is_mu3O = self._detect_mu_oxygens(Z, self.adj, self.is_metal)

        self.is_aromatic_C = np.zeros(self.N, float)
        for i in range(self.N):
            if Z[i] == 6 and self.is_aromatic[i] == 1.0:
                self.is_aromatic_C[i] = 1.0

        self.is_linker = np.zeros(self.N, float)
        for i in range(self.N):
            if (
                (not self.is_metal[i])
                and (not self.is_carboxylate_O[i])
                and (not self.is_aromatic_C[i])
                and Z[i] in [6, 7]
            ):
                self.is_linker[i] = 1.0

        self.bond_types = np.zeros((self.N, 6), float)

        for a, b in self.bond_pairs:
            Za, Zb = Z[a], Z[b]

            if self.is_metal[a] and Zb == 8:
                self.bond_types[a][0] += 1
            if self.is_metal[b] and Za == 8:
                self.bond_types[b][0] += 1

            if self.is_metal[a] and Zb == 7:
                self.bond_types[a][1] += 1
            if self.is_metal[b] and Za == 7:
                self.bond_types[b][1] += 1

            if self.is_carboxylate_O[a]:
                self.bond_types[b][2] += 1
            if self.is_carboxylate_O[b]:
                self.bond_types[a][2] += 1

            if self.is_aromatic_C[a] and self.is_aromatic_C[b]:
                self.bond_types[a][3] += 1
                self.bond_types[b][3] += 1

            if self.is_mu2O[a]:
                self.bond_types[b][4] += 1
            if self.is_mu2O[b]:
                self.bond_types[a][4] += 1

            if self.is_mu3O[a]:
                self.bond_types[b][5] += 1
            if self.is_mu3O[b]:
                self.bond_types[a][5] += 1

        # 4) Phase2: 여기서 좌표에 작은 perturb 적용
        self._apply_random_perturbation()

        # 5) perturb된 구조 기준으로 force 초기화
        self.forces = self.atoms.get_forces().astype(np.float32)
        self.prev_forces = np.zeros_like(self.forces)
        self.prev_disp = np.zeros_like(self.forces)

        self.step_count = 0
        self.COM_prev = self.atoms.positions.mean(axis=0).astype(np.float32)

        # feature_dim 계산은 force 초기화 후
        self.feature_dim = len(self._make_feature(0))

        return self._obs()

    # ============================================================
    def _rel_vec(self, i, j):
        disp = self.atoms.positions[j] - self.atoms.positions[i]
        cell = self.atoms.cell.array
        frac = np.linalg.solve(cell.T, disp)
        frac -= np.round(frac)
        return frac @ cell

    # ============================================================
    # Hops 1–3
    # ============================================================
    def _get_hop_sets(self, idx, max_hop=3):
        visited = set([idx])
        frontier = [idx]
        hop_map = {1: [], 2: [], 3: []}

        for hop in range(1, max_hop + 1):
            nxt_frontier = []
            for node in frontier:
                for nxt in self.adj[node]:
                    if nxt not in visited:
                        visited.add(nxt)
                        nxt_frontier.append(nxt)
                        hop_map[hop].append(nxt)
            frontier = nxt_frontier

        return hop_map

    # ============================================================
    # Feature
    # ============================================================
    def _make_feature(self, idx):

        ri = self.covalent_radii[idx]
        gi = self.forces[idx]
        gprev = self.prev_forces[idx]

        gnorm = max(np.linalg.norm(gi), 1e-12)

        core = np.concatenate([
            np.array([ri, min(gnorm, self.cmax), np.log(gnorm + 1e-6)]),
            gi,
            self.prev_disp[idx],
            gi - gprev,
        ])

        roles = np.array([
            self.is_aromatic[idx],
            self.is_metal[idx],
            self.is_linker[idx],
            self.is_carboxylate_O[idx],
            self.is_mu2O[idx],
            self.is_mu3O[idx],
        ])

        return np.concatenate([core, roles, self.bond_types[idx]])

    # ============================================================
    # Observation
    # ============================================================
    def _obs(self):

        obs_list = []

        for i in range(self.N):

            fi = self._make_feature(i)
            hop_sets = self._get_hop_sets(i)

            selected = []

            for j in hop_sets[1]:
                if len(selected) < self.k:
                    selected.append(j)

            for j in hop_sets[2]:
                if len(selected) < self.k:
                    selected.append(j)

            remain = self.k - len(selected)
            if remain > 0 and len(hop_sets[3]) > 0:
                cand = hop_sets[3]
                if len(cand) <= remain:
                    selected += cand
                else:
                    selected += list(np.random.choice(cand, remain, False))

            while len(selected) < self.k:
                selected.append(None)

            nbr_feats = []
            dists = []
            vecs = []

            for j in selected:
                if j is None:
                    nbr_feats.append(np.zeros_like(fi))
                    dists.append(0.0)
                    vecs.append(np.zeros(3))
                else:
                    fj = self._make_feature(j)
                    rel = self._rel_vec(i, j)
                    nbr_feats.append(fj)
                    dists.append(np.linalg.norm(rel))
                    vecs.append(rel)

            block = [fi] + nbr_feats
            block.append(np.array(dists))
            block.append(np.array(vecs).reshape(-1))

            obs_list.append(np.concatenate(block))

        return np.array(obs_list, float)

    # ============================================================
    # STEP  (Stabilized RL version)
    # ============================================================
    def step(self, action):

        self.step_count += 1
        action = np.clip(action, -1.0, 1.0)

        # -----------------------------
        # 1) Force-adaptive displacement
        # -----------------------------
        gnorm = np.linalg.norm(self.forces, axis=1)
        scale = np.minimum(gnorm, self.cmax).reshape(-1, 1)

        disp = 0.003 * action * (scale / self.cmax)
        self.atoms.positions += disp

        new_forces = self.atoms.get_forces().astype(np.float32)

        old_norm = np.maximum(np.linalg.norm(self.forces, axis=1), 1e-12)
        new_norm = np.maximum(np.linalg.norm(new_forces, axis=1), 1e-12)

        # -----------------------------
        # 2) Force reward  (×10)
        # -----------------------------
        r_f = 10.0 * (np.log(old_norm + 1e-6) - np.log(new_norm + 1e-6))
        reward = r_f.copy()

        # -----------------------------
        # 3) COM penalty (stabilized)
        # -----------------------------
        COM_new = self.atoms.positions.mean(axis=0)
        delta_COM = np.linalg.norm(COM_new - self.COM_prev)

        reward -= self.com_lambda * delta_COM
        self.COM_prev = COM_new.copy()

        if delta_COM > self.com_threshold:
            return self._obs(), reward, True

        # -----------------------------
        # 4) Bond penalty (×1, capped at 3)
        # -----------------------------
        for idx, (a, b) in enumerate(self.bond_pairs):

            rel = self._rel_vec(a, b)
            d = np.linalg.norm(rel)
            d0 = self.bond_d0[idx]
            ratio = d / d0

            stretch = max(0.0, ratio - self.bond_break_ratio)
            compress = max(0.0, 0.6 - ratio)

            penalty = 1.0 * self.k_bond * np.sqrt(stretch**2 + compress**2)
            penalty = min(penalty, 3.0)

            reward -= penalty

            if ratio > 6.0 or ratio < 0.25:
                return self._obs(), reward, True

        # -----------------------------
        # 5) Termination conditions
        # -----------------------------
        done = False
        if np.mean(new_norm) < self.fmax_threshold:
            done = True
        if self.step_count >= self.max_steps:
            done = True

        # -----------------------------
        # Update memory
        # -----------------------------
        self.prev_disp = disp.copy()
        self.prev_forces = self.forces.copy()
        self.forces = new_forces.copy()

        return self._obs(), reward, done

